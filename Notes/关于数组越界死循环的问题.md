# 数组越界访问导致死循环

## 问题，看看下列代码

```c++
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int i = 0;
    int arr[3] = {0};
    for (; i <= 3; i++)
    {
        arr[i] = 0; // 数组越界死循环问题
        printf("hello world\n");
    }
    return 0;
}
```

## 分析

代码中，i, arr都是局部变量，局部变量的存储是在内存中的栈区上开辟空间存储的，栈区存储是先使用高地址，后使用低地址。

而数组是随着下标的增加，地址由低变高的。

所以当数组被越界访问， arr[3]和i的地址相同，改变arr[3]的值时，i也被改变，所以导致了死循环。

示列图如下

```c++
高地址     i      -> i 先在高地址创建
                 -> 数组向后越界访问的地址是逐渐增加的，所以越界就可以向上访问到i, 一旦访问到i，将其置成0， 程序将陷入死循环
          arr[2] 
          arr[1] -> 数组所在的地址比i低，后创建，随着下标的增长，地址由低到高
          arr[0]

低地址
```

## 总结

上面我们解释了这个程序出现死循环的原因，当然决定这种结果有一个重要的原因就是我们把 i 定义在了数组 arr 之前，所以它的地址更高，因此数组向后越界才会访问到 i。

如果我们将 i 定义在数组 arr 之后，就不会访问到 i 了，也就不会死循环了。
